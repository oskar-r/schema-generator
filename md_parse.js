const fs = require('fs');
const pmt = require('parse-markdown-table');
const fetch= require('node-fetch');
const toSnakeCase = str =>
  str &&
  str
    .match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g)
    .map(x => x.toLowerCase())
    .join('_');

(async () => {
  var myArgs = process.argv.slice(2);
  let mdCont = '';
  if (myArgs[0] && myArgs[0].includes("http")) {
    const resp = await fetch(myArgs[0]);
    mdCont = await resp.text();
  } else {
    console.log()
    const filename = (myArgs[0] && myArgs[0].length > 0) ? myArgs[0] : 'mdm.md'
    mdCont = fs.readFileSync(filename, {encoding:'utf8', flag:'r'});
  }
  const tableSchema = await parser(mdCont);
  
  //const mdCont = fs.readFileSync('mdm.md', {encoding:'utf8', flag:'r'});
  
  fs.writeFileSync('schema.db', tableSchema, {encoding:'utf8', flag:'w'});
})().catch(e => {
  console.error(e);
});

/*
async function main() {  
  const mdCont = fs.readFileSync('mdm.md', {encoding:'utf8', flag:'r'});
  const tableSchema = await parser(mdCont);
  return tableSchema;
}
*/

async function parser(mdCont) {
  const table = await pmt.createMarkdownArrayTable(mdCont);
  const tableObjects = {};
  let currentHeadline = '';
  const tblMatchRE = /^###\s/gm;
  for await (const row of table.rows) {
    if (row[0].match(tblMatchRE)) {
      currentHeadline = toSnakeCase(row[0].replace("### ",'').trim());
      tableObjects[currentHeadline] = [];
      continue;
    }
    if(row.length > 1) {
      if (row[1].includes('Sub-property')) {
        continue;
      }
      if(row[1].includes(':-----')) {
        continue;
      }
    }

    if (row.length > 5) {
      let obj = new Object();
      obj.attribute = row[1];
      obj.mult = row[2];
      obj.typ = row[3] ? row[3] : '';
      obj.enum = row[4] ? row[4] : '';
      obj.desc = row[5] ? row[5] : '';
      if (tableObjects[currentHeadline]) {
        tableObjects[currentHeadline].push(obj);
      }
    }
  }
  console.log(tableObjects);
  
  const regex = /.*\(.*#(.*)\)/gm;
  let tableSchema = '';
  for (const [key, value] of Object.entries(tableObjects)) {
    if(Array.isArray(value) && value.length > 0) {
      tableSchema = tableSchema + `Table ${toSnakeCase(key)} {\n`;
      value.forEach((row) => {
        if (row.typ) {
          //Reference to another table
          let ref = '';
          if (row.typ.includes('#')) {
            const t = row.typ.trim().split("#");
            if(t[1]) {
              //Ugly but reg ex above not working in node ???
              const tbl = toSnakeCase(t[1].replace(")",'').replace('~'));
              if (tableObjects[tbl]) {
                let dir = '<';
                switch (row.mult) {
                  case "0 - 1":
                    dir = '-'; //One-to-One;
                    break;
                  case "1":
                    dir = '-';
                    break;
                  case "1 - n":
                    dir = '<';
                    break;
                }
                ref = `[ref: ${dir} ${tbl}.id]`;
                //Add an id reference is not already existing
                if (tableObjects[tbl].filter((i) => i.attribute == 'id').length == 0) {
                  tableObjects[tbl].push({attribute: 'id', typ: 'uuid', desc: 'autogenerated id'});
                  row.typ = 'uuid';
                } else {
                  row.typ = tableObjects[tbl].filter((i) => i.attribute == 'id')[0].typ;
                }
              } else {
                //This is an reference to an unknown table
                row.typ = 'uuid'
                ref = "[note: '!!!Missing table relation']";
              }
            }
          } else {
            const t = row.typ.trim().split("]")
            let tt = row.typ.trim()
            if (t.length == 2) {
              tt = t[0].replace("[",'');
            }
            //Special cases
            switch (tt) {
              case 'KeyValues':
                row.typ = 'json';
                break;
              case '?':
                row.typ = 'string';
                break;  
              default:
                row.typ = tt;
            }
            //Set ref to column description instead
            ref = (row.desc) ? `[note: '${row.desc.replace("'",'').replace('https://','')}']`:  `[note: '${row.desc}']`
          }
          tableSchema = tableSchema + `\t${toSnakeCase(row.attribute)} ${row.typ} ${ref}\n`;
        } else {
          //console.log(row);
        }
      })
      tableSchema = tableSchema + '}\n\n';
    }
  }
  return tableSchema;
}
