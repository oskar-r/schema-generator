const fs = require('fs');
const pmt = require('parse-markdown-table');
const toSnakeCase = str =>
  str &&
  str
    .match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g)
    .map(x => x.toLowerCase())
    .join('_');

(async () => {
  const mdCont = fs.readFileSync('mdm.md', {encoding:'utf8', flag:'r'});
  const tableSchema = await parser(mdCont);
  fs.writeFileSync('schema.db', tableSchema, {encoding:'utf8', flag:'w'});
})().catch(e => {
  console.error(e);
});

/*
async function main() {  
  const mdCont = fs.readFileSync('mdm.md', {encoding:'utf8', flag:'r'});
  const tableSchema = await parser(mdCont);
  return tableSchema;
}
*/

async function parser(mdCont) {
  const table = await pmt.createMarkdownArrayTable(mdCont);
  const tableObjects = {};
  let currentHeadline = '';

  for await (const row of table.rows) {
    if (row[0].includes('##')) {
      currentHeadline = toSnakeCase(row[0].replace("## ",'').trim());
      tableObjects[currentHeadline] = [];
      continue;
    }
    if(row.length > 1) {
      if (row[1].includes('Attribute')) {
        continue;
      }
      if(row[1].includes(':-----')) {
        continue;
      }
    }

    if (row.length > 1) {
      let obj = new Object();
      obj.attribute = row[1];
      obj.mult = row[2];
      obj.typ = row[3];
      obj.desc = row[4];
      if (tableObjects[currentHeadline]) {
        tableObjects[currentHeadline].push(obj);
      }
    }
  }
  const regex = /.*\(.*#(.*)\)/gm;
  let tableSchema = '';
  for (const [key, value] of Object.entries(tableObjects)) {
    if(Array.isArray(value) && value.length > 0) {
      tableSchema = tableSchema + `Table ${toSnakeCase(key)} {`;
      value.forEach((row) => {
        //Reference to another table
        let ref = '';
        if (row.typ.includes('#')) {
          const t = row.typ.trim().split("#");
          if(t[1]) {
            //Ugly but reg ex above not working in node ???
            const tbl = toSnakeCase(t[1].replace(")",'').replace('~'));
            if (tableObjects[tbl]) {
              let dir = '<';
              switch (row.mult) {
                case "0 - 1":
                  dir = '-'; //One-to-One;
                  break;
                case "1":
                  dir = '-';
                  break;
                case "1 - n":
                  dir = '<';
                  break;
              }
              ref = `[ref: ${dir} ${tbl}.id]`;
              //Add an id reference is not already existing
              if (tableObjects[tbl].filter((i) => i.attribute == 'id').length == 0) {
                tableObjects[tbl].push({attribute: 'id', typ: 'uuid', desc: 'autogenerated id'});
                row.typ = 'uuid';
              } else {
                row.typ = tableObjects[tbl].filter((i) => i.attribute == 'id')[0].typ;
              }
            } else {
              //This is an reference to an unknown table
              row.typ = 'uuid'
              ref = "[note: '!!!Missing table relation']";
            }
          }
        } else {
          //Special cases
          if (row.typ.includes('[object map]')) {
            row.typ = 'json';
          } else if (row.typ.includes('Lookup code to kurre reference data table to describe what this record is.')) {
            row.typ = 'uuid'; //TODO handle properly with reference instead
          } else if (row.typ.includes('[date]')) {
            row.type = 'timestamp';
          }
          //Set ref to column description instead
          ref = `[note: '${row.desc}']`;
        }
        tableSchema = tableSchema + `\t${toSnakeCase(row.attribute)} ${row.typ} ${ref}\n`;
      })
      tableSchema = tableSchema + '}\n\n';
    }
  }
  return tableSchema;
}

